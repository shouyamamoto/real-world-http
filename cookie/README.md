# cookie
cookieはWebサイトの情報をブラウザ側に保存する仕組み。サーバー側がブラウザに保存しておく情報を指示する。  
cookieもHTTPヘッダーをインフラとして実装されている。  
cookieの最大容量は4MB。
  
cookieは以下のように「名前＝値」の形式で返信する。  
```
Cookie: LAST_ACCESS_DATE=Jun/31/2016
Cookie: LAST_ACCESS_TIME=12:18
```
  
以下のコードは初回訪問かどうかを判定して表示内容を変えている。
```go
func handler(w http.ResponseWriter, r *http.Request) {
    w.Handler.Add("Set-Cookie", "VISIT=TRUE")
    if _, ok := r.Header["Cookie"]; ok {
        fmt.Println("2回目以降")
    } else {
        fmt.Println("初回訪問")
    }
}
```

上記のようにすることで、HTTPはステートレスを基本に開発されているが、あたかもサーバが状態を保持したステートフルであるかのように見えるサービスを作ることができる。
  
## cookieに制約を与える
cookieは特定のサービスのトークンとして利用されることが多いため、cookieを本来必要としないサーバーに送信することはセキュリティのリスクを高める。  
そのため、送信先を制御したり寿命を設定するような属性が存在する。HTTPクライアントには、これらの属性を解釈し、cookieの送信をコントロールする責務がある。  
<br>
属性はセミコロン区切りでいくつも書くことができる。また、属性名は大文字小文字を区別しない。  
  
|属性名|内容|
|---|---|
|Expires, Max-Age|クッキーの寿命を設定する。Max-Ageは秒で指定。現在時刻から指定された秒数を足した時間に無効になる。Expiresは、`Wed, 09 Jun 2021 10:18:14 GMT`といった形式の文字列を解釈する|
|Domain|クライアントからcookieを送る対象のサーバ。省略時はcookieを発行したサーバになる|
|Path|クライアントからcookieを送る対象のサーバのパス。省略時はcookieを発行したサーバのパスになる|
|Secure|https接続での安全な接続時以外は、クライアントからサーバへcookie送信をしない。http接続が行われるときにはブラウザが警告を出し、ページへのアクセスを止めるため、流出を防ぐ|
|HttpOnly|JavaScriptエンジンからcookieを隠すことができる。XSSなど、悪意のあるJavaScriptが実行されるセキュリティリスクに対応する|
|SameSite|Chromeが導入した属性で、同じオリジンのドメインに対して送信するようになる|

## cookieを使ったセッション管理
最近、認証とセッションで最も使われているのが、フォームを使ったログインとcookieを使ったセッション管理の組み合わせ。  
<br>
クライアントは、フォームでIDとパスワードを送信する。（SSL/TLSが必須）  
サーバ側ではIDとパスワードで認証し、問題がなければセッショントークンを発行する。サーバはセッショントークンとRDBなどに保存しておく。  
トークンはcookieとしてクライアントに返却され、2回目以降のアクセスではcookieを送信することでログイン済みのクライアントであることがサーバでわかる。
